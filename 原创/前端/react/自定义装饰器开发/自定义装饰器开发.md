# 仿 react-redux connect 实现自定义装饰器开发



### 什么是装饰器(`Decorator`)？

> 注：装饰器只能装饰类 不能装饰函数 所以只能在类组件上使用

``` jsx
import React from 'react'
import {connect} from 'react-redux'

@connect()
export default class Demo extends Components{
  //...
}
```

`@connect`就是装饰器(`Decorator`)，如果熟悉`react-redux`就一定会知道 `@connect`的另一种写法。

``` jsx
import React from 'react'
import {connect} from 'react-redux'
class Demo extends Components{
  //...
}
export default connect()(Demo)
```

所以显而易见装饰器的本质是函数,一个被柯里化的[高阶函数](https://zh-hans.reactjs.org/docs/higher-order-components.html)(`HOC`)。

```jsx
function connect (){
  //...
  return function (WrappedComponent){
    //...
    return <WrappedComponent/>
  }
}
```



### 什么是[高阶函数](https://zh-hans.reactjs.org/docs/higher-order-components.html)(`HOC`)？

> **概念：高阶组件是参数为组件，返回值为新组件的函数**

#### 高阶组件能做什么？

我们都知道[自定义Hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)可以将组件逻辑提取到可重用的函数中，从而使不同的组件更好的复用逻辑。那类组件又要如何做到逻辑复用呢？答案是高阶组件。

#### 业务案例

以商城业务出发，必然有各种不同的商品列表页，但有着相同的加购逻辑。在函数式组件中，我们可以用[自定义Hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)实现逻辑的抽离和复用，在类组件中就需要用到高阶组件。

```jsx
// 高阶组件
import React from 'react'
function addCartHOC (WrappedComponent){
  return class AddCart extends Components{
    
    constructor(props) {
      super(props);
    }
    
    /**
      * 加购方法
      */
    handleAddCart = ()=>{
      ...
    }
    
    render(){
      return <WrappedComponent {...this.props} onAddCart={this.handleAddCart}/>
    }
  }
}
```

那么我们就可以在页面组件中这样使用

```jsx
// 页面组件
import React from 'react'
class Page extends Components {
  constructor(props) {
    super(props);
  }
  
  render(){
    const { onAddCart } = this.props
    return (
    	<div>
        <button onClick={onAddCart}>加购</button>
      </div>
    )
  }
}
export default addCartHOC(Page)
```

而我们也可以进一步改进我们的高阶组件，实现装饰器。

```jsx
// 装饰器
import React from 'react'

function addCart() {
  return function addCartHOC(WrappedComponent) {
    return class AddCart extends Components {

      constructor(props) {
        super(props);
      }

      /**
       * 加购方法
       */
      handleAddCart = () => {
        //...
      }

      render() {
        return <WrappedComponent {...this.props} onAddCart={this.handleAddCart}/>
      }
    }
  }
}
```

那么我们在页面组件上就可以使用更简洁的使用高阶函数

```jsx
// 页面组件
import React from 'react'

@addCart
export default class Page extends Components {
  constructor(props) {
    super(props);
  }
  
  render(){
    const { onAddCart } = this.props
    return (
    	<div>
        <button onClick={onAddCart}>加购</button>
      </div>
    )
  }
}
```



### `Taro` 中使用

当我们使用上面开发的装饰器`addCart`，复用至页面组件时会发现小程序的生命周期，例如：`onLoad`、`onShow`（即`Taro`页面组件的生命周期 `componentDidShow` ）等无法触发。

那是因为`Taro` 处理生命周期的逻辑，如 `onShow`的流程是由小程序触发 `onShow`，找到页面组件实例，调用上面的 `componentDidShow` 方法。那么参考 `react-redux`源码。

```js
import hoistStatics from 'hoist-non-react-statics';
//...
function wrapWithConnect(WrappedComponent) {
	//...
  if (forwardRef) {
    const _forwarded = React.forwardRef(function forwardConnectRef(props,ref) {
      return <Connect {...props} reactReduxForwardedRef={ref} />
    })

    const forwarded = _forwarded as ConnectedWrapperComponent
    forwarded.displayName = displayName
    forwarded.WrappedComponent = WrappedComponent
    return hoistStatics(forwarded, WrappedComponent)
  }

  return hoistStatics(Connect, WrappedComponent)
}
```

那么发现不难发现`react-redux`是使用[`hoist-non-react-statics`](https://github.com/mridgway/hoist-non-react-statics)合并了静态方法，就比如：`onLoad`、`onShow`（即`Taro`页面组件的生命周期 `componentDidShow` ）。

那么我们修改装饰器代码

```js
// 装饰器
import React from 'react'
import hoistStatics from 'hoist-non-react-statics';

function addCart() {
  return function addCartHOC(WrappedComponent) {
     class AddCart extends Components {

      constructor(props) {
        super(props);
      }

      /**
       * 加购方法
       */
      handleAddCart = () => {
      	//...
      }

      render() {
        return <WrappedComponent {...this.props} onAddCart={this.handleAddCart}/>
      }
    }
    return hoistStatics(AddCart,WrappedComponent)
  }
}
```

对应的我们页面组件则不需要改变

```jsx
// 页面组件
import React from 'react'

@addCart
export default class Page extends Components {
  constructor(props) {
    super(props);
  }
  
  render(){
    const { onAddCart } = this.props
    return (
    	<div>
        <button onClick={onAddCart}>加购</button>
      </div>
    )
  }
}
```

### 最后

装饰器是可以传递参数的与`react-redux`的`connect`方法类似，只是太简单了没什么好写的。熟悉`vue`的可以把高阶函数当成`vue`里的`mixin`