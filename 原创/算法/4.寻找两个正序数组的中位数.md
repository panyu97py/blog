# 寻找两个正序数组的中位数

## 题目描述

给定两个大小为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为`O(log(m + n))`。

你可以假设 `nums1` 和 `nums2` 不会同时为空。

### 示例1

```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```

### 示例 2

```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

## 题解

### 题解一：暴力解法

#### 思路

根据题目描述及示例我们可以知道，用 len 表示合并后数组的长度如果是奇数，我们需要知道第 `（len+1）/2` 个数就可以了，如果遍历的话需要遍历 `Math.floor(len/2 ) + 1`
次。如果是偶数，我们需要知道第 `len/2`和 `len/2+1` 个数的值，也是需要遍历 `len/2+1` 次。所以遍历的话，奇数和偶数都是 `len/2+1` 次。

即：

* 若`len%2===1`中位数就是位于合并后数组`Math.floor(len/2)+1`的数字。
* 若`(m+n)%2===0`中位数就是位于合并后数组`len/2`和`len/2+1`的数字的平均数。

所以我们需要做的就是排序就可以了,这里我们采用指针法排序这样最多只需要移动`len/2+1`就能获得答案。

时间复杂度：遍历 `len/2+1` 次，`len=m+n`，所以时间复杂度是 `O(m+n)`。 空间复杂度：我们申请了常数个变量，也就是`m`，`n`，`len`，`pointer1`，`pointer2`，`newVal`
，`oldVal` 以及 `i`。

总共 8 个变量，所以空间复杂度是 `O(1)`。

但这并不符合题目中要求的时间复杂度`O(log(m + n))`

#### 代码

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function (nums1, nums2) {
        let m = nums1.length
        let n = nums2.length
        let len = m + n
        let pointer1 = 0, pointer2 = 0
        let newVal, oldVal
        for (let i = 0; i <= len / 2; i++) {
            oldVal = newVal
            if (pointer1 < m && (nums1[pointer1] <= nums2[pointer2] || pointer2 >= n)) {
                newVal = nums1[pointer1++]
            } else {
                newVal = nums2[pointer2++]
            }
        }
        if ((len % 2) === 0) {
            return (newVal + oldVal) / 2
        } else {
            return newVal
        }
    };
```

### 题解二：二分法

#### 思路

> 该思路源自官方题解加以自己的理解

假设两个有序数组的长度分别为 `m` 和 `n` 。提议中寻找中位数即 当 `(m+n)%2===0` 即为寻找两个数组中 第`(m+n)>>1`小 与 第`((m+n)>>1)+1`小 的平均数， 当`(m+n)%2===1`
时即为寻找两个数组中第`((m+n)>>1)+1`小的值。

那么本题的关键点在于如何取查找两个有序数组第 `k` 小的值，`k`我们可以理解为`(m+n)>>1`或`((m+n)>>1)+1`。

基于题目中的要求复杂度 `O(log(m+n))` 所以采用二分法查找。这里二分法的使用相对难以理解，如果理解透彻相信会对二分法有着更深地理解。

在上述的暴力解法中我们通过双指针逐个对比两个数组中数值的大小来查找第`k`小的值。其实二分法查找的原理与之相类似， 也是通过比较两个数组中数值的大小来查找第`k`小的值来查找第`k`
小的值，只不过二分法查找在双指针查找的基础上多做了一层逻辑来简化时间复杂度。

假设两个有序数组分别是 `A` 和 `B`,要找到第 `k` 个元素。双指针查找则从`A[0]`与`B[0]`开始对比，而二分查找我们直接从`A[(k>>1)-1]`与`B[(k>>1)-1]`开始对比。
那么这样对比有什么优势？为什么可以这么对比？我们举一个🌰：

* 步骤1：图中 `A` 与 `B` 两个数组假设我们需要查找他第`4`小的数即`k=4`那么`(k>>1)-1===1`那么就是对比`A[1]`与`B[1]`。🌰 中`A[1]<B[1]`
  所以`A[0]`至`A[(k>>1)-1]`这`k>>1`个数中不可能包含第`k`小的数。我们理一下`A[0]`至`A[(k>>1)-1]`与`B[0]`至`B[(k>>1)-1]`共有`k`个数。
  `A[(k>>1)-1]<B[(k>>1)-1]`是不是就代表着`A[(k>>1)-1]`最多只有`2*((k>>1)-1)`即`k-2`个元素比他小,那`A[(k>>1)-1]`最多是第`k-1`
  个元素，所以`A[0]`至`A[(k>>1)-1]`这`k>>1`个数中,不可能包含第`k`小的数。

![](./assets/4.寻找两个正序数组的中位数.assets/20221231161211.jpg)

* 步骤2：排除了`A[(k>>1)-1]<B[(k>>1)-1]`这`k>>1`个元素后我们应查找剩余元素中第`k-k>>1`小的值。为了方便理解我们假定`l=k-k>>1`即`l=2`
  所以我们需要比较`A[(k>>1)+(l>>1)-1]`与`B[(l>>1)-1]`,即`A[2]`与`B[0]`。`A[2]>B[0]`故`B[0]`至`B[(l>>1)-1]`排除。

![](./assets/4.寻找两个正序数组的中位数.assets/20221231163918.jpg)

* 步骤3：排除了`B[0]`~`B[(l>>1)-1]`这`l>>1`个元素后我们应查找剩余元素中第`k-(k>>1)-(l>>1)`小的值。为了方便理解我们假定`j=k-(k>>1)-(l>>1)`即`j=1`
  所以我们需要比较`A[(k>>1)+(l>>1)+(j>>1)-1]`与`B[(l>>1)+(j>>1)-1]`,即`A[2]`与`B[1]`。由于`j>>1===0`等于`1`且`A[2]>B[1]`故`B[1]`就是我们需要查找的第`5`小数。

![](./assets/4.寻找两个正序数组的中位数.assets/20221231165156.jpg)

#### 代码实现
> 敬请期待... (还没写完回头补上)

### 题解三：划分数组 + 二分法

#### 思路

> 该思路源自官方题解加以自己的理解



为了使用划分的方法解决这个问题，需要理解「中位数的作用是什么」。在统计中，中位数被用来：**将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。**



如何找到这个元素，我们举一个🌰：

* 首先根据中位数的概念，在任意位置`i`与`j`将数组`A`与数组`B`划分为两个长度相等的部分。即：`(m+n)%2===0`时满足`i+j=m-i+n-j`、`(m+n)%2===1`时满足`i+j=m-i+n-j+1`。总结成代码就是`j+i=(m+n+1)>>1`,这里如果不理解可以去看看位运算。

![划分数组](assets/4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.assets/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84.png)

* 题中提到数组`A`与数组`B`是正序数组。那么必然`A[i]>=A[i-1]`、`B[j]>=B[j-1]`若要满足**其中一个子集中的元素总是大于另一个子集中的元素**则必须满足`A[i]>=B[j-1]`、`B[j]>=A[i-1]`

![划分数组2](assets/4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.assets/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%842.png)

![划分数组3](assets/4.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.assets/%E5%88%92%E5%88%86%E6%95%B0%E7%BB%843.png)

* 当`i`从`0 ∼ m`递增时，`A[i−1]`递增,`B[j]`递减，所以一定存在一个最大的`i`满足`A[i−1]≤B[j]`。那么如果`i`是最大的那么`i+1`必定不满足对角`<=`。即`A[i]>B[j-1]`刚好满足上面提到的`A[i]>=B[j-1]`(ps:为什么可以这样转换？因为由**两个子集总长度奇偶**决定**必须长度相等或相差一**，故一边`+1`另一边则`-1`)，所以我们只需要找到最大的`i`满足`A[i−1]≤B[j]`即可准确划分集合。那么就可以根据`(m+n)%2`判断中位数：
  * `(m+n)%2===1`中位数为划分前一部分元素中的最大值。
  * `(m+n)%2===0`中位数为划分前一部分元素中的最大值与划分后一部分元素中的最小值的平均值。
* 这里我们可以用二分法快速查找`i`在`0 ∼ m`区间找到最大的`i`满足`A[i−1]≤B[j]`就找到了中位数。

#### 代码实现

> 敬请期待... (还没写完回头补上)

### 
