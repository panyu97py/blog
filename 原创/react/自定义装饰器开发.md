# 仿 react-redux connect 实现自定义装饰器开发



### 什么是装饰器(`Decorator`)？

>
> [注：装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。](https://www.bookstack.cn/read/es6-3rd/spilt.3.docs-decorator.md)

``` jsx
import React from 'react'
import {connect} from 'react-redux'

@connect()
export default class Demo extends Components{
  //...
}
```

`@connect`就是装饰器(`Decorator`)，如果熟悉`react-redux`就一定会知道 `@connect`的另一种写法。

``` jsx
import React from 'react'
import {connect} from 'react-redux'
class Demo extends Components{
  //...
}
export default connect()(Demo)
```

所以显而易见装饰器的本质是函数,一个被柯里化的[高阶函数](https://zh-hans.reactjs.org/docs/higher-order-components.html)(`HOC`)。

```jsx
function connect (){
  //...
  return function (WrappedComponent){
    //...
    return <WrappedComponent/>
  }
}
```



### 什么是[高阶函数](https://zh-hans.reactjs.org/docs/higher-order-components.html)(`HOC`)？

> **概念：高阶组件是参数为组件，返回值为新组件的函数**

#### 高阶组件能做什么？

我们都知道[自定义Hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)可以将组件逻辑提取到可重用的函数中，从而使不同的组件更好的复用逻辑。那类组件又要如何做到逻辑复用呢？答案是高阶组件。

#### 业务案例

以商城业务出发，必然有各种不同的商品列表页，但有着相同的加购逻辑。在函数式组件中，我们可以用[自定义Hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)实现逻辑的抽离和复用，在类组件中就需要用到高阶组件。

```jsx
// 高阶组件
import React from 'react'
function addCartHOC (WrappedComponent){
  return class AddCart extends Components{
    
    constructor(props) {
      super(props);
    }
    
    /**
      * 加购方法
      */
    handleAddCart = ()=>{
      ...
    }
    
    render(){
      return <WrappedComponent {...this.props} onAddCart={this.handleAddCart}/>
    }
  }
}
```

那么我们就可以在页面组件中这样使用

```jsx
// 页面组件
import React from 'react'
class Page extends Components {
  constructor(props) {
    super(props);
  }
  
  render(){
    const { onAddCart } = this.props
    return (
    	<div>
        <button onClick={onAddCart}>加购</button>
      </div>
    )
  }
}
export default addCartHOC(Page)
```

而我们也可以进一步改进我们的高阶组件，实现装饰器。

```jsx
// 装饰器
import React from 'react'

function addCart() {
  return function addCartHOC(WrappedComponent) {
    return class AddCart extends Components {

      constructor(props) {
        super(props);
      }

      /**
       * 加购方法
       */
      handleAddCart = () => {
        //...
      }

      render() {
        return <WrappedComponent {...this.props} onAddCart={this.handleAddCart}/>
      }
    }
  }
}
```

那么我们在页面组件上就可以使用更简洁的使用高阶函数

```jsx
// 页面组件
import React from 'react'

@addCart
export default class Page extends Components {
  constructor(props) {
    super(props);
  }
  
  render(){
    const { onAddCart } = this.props
    return (
    	<div>
        <button onClick={onAddCart}>加购</button>
      </div>
    )
  }
}
```



### `Taro` 中使用

当我们使用上面开发的装饰器`addCart`，复用至页面组件时会发现小程序的生命周期，例如：`onLoad`、`onShow`（即`Taro`页面组件的生命周期 `componentDidShow` ）等无法触发。

那是因为`Taro` 处理生命周期的逻辑，如 `onShow`的流程是由小程序触发 `onShow`，找到页面组件实例，调用上面的 `componentDidShow` 方法。那么参考 `react-redux`源码。

```jsx
import hoistStatics from 'hoist-non-react-statics';
//...
function wrapWithConnect(WrappedComponent) {
	//...
  if (forwardRef) {
    const _forwarded = React.forwardRef(function forwardConnectRef(props,ref) {
      return <Connect {...props} reactReduxForwardedRef={ref} />
    })

    const forwarded = _forwarded as ConnectedWrapperComponent
    forwarded.displayName = displayName
    forwarded.WrappedComponent = WrappedComponent
    return hoistStatics(forwarded, WrappedComponent)
  }

  return hoistStatics(Connect, WrappedComponent)
}
```

那么发现不难发现`react-redux`是使用[`hoist-non-react-statics`](https://github.com/mridgway/hoist-non-react-statics)合并了静态方法，就比如：`onLoad`、`onShow`（即`Taro`页面组件的生命周期 `componentDidShow` ）。那我们来看看[`hoist-non-react-statics`](https://github.com/mridgway/hoist-non-react-statics)做了什么。

```javascript
// ...

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  // memo 组件与 forwardRef z组件静态属性及方法 || react class 组件静态属性及方法
  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

// ...

export default function hoistNonReactStatics(targetComponent, sourceComponent, excludelist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            const inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, excludelist);
            }
        }

      	// 获取所有原型属性名 Object.getOwnPropertyNames
        let keys = getOwnPropertyNames(sourceComponent);

      	// 获取对象自身的所有 Symbol 属性的数组 Object.getOwnPropertySymbols
        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

      	// 获取目标组件与来源组件的静态方法（注意：这里返回的静态方法指的是定义好的不参与合并的方法及属性）
        const targetStatics = getStatics(targetComponent);
        const sourceStatics = getStatics(sourceComponent);

        for (let i = 0; i < keys.length; ++i) {
            const key = keys[i];
          	
          	// 排除过滤列表、 来源组件及目标组件中不需要参与合并的方法及属性
            if (!KNOWN_STATICS[key] &&
                !(excludelist && excludelist[key]) &&
                !(sourceStatics && sourceStatics[key]) &&
                !(targetStatics && targetStatics[key])
            ) {
              	// 获取对象自有属性对应的属性描述符 Object.getOwnPropertyDescriptor
                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties

                  	// 合并方法及属性 Object.defineProperty
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }
    }

    return targetComponent;
};

```

那么我们修改装饰器代码

```jsx
// 装饰器
import React from 'react'
import hoistStatics from 'hoist-non-react-statics';

function addCart() {
  return function addCartHOC(WrappedComponent) {
     class AddCart extends Components {

      constructor(props) {
        super(props);
      }

      /**
       * 加购方法
       */
      handleAddCart = () => {
      	//...
      }

      render() {
        return <WrappedComponent {...this.props} onAddCart={this.handleAddCart}/>
      }
    }
    return hoistStatics(AddCart,WrappedComponent)
  }
}
```

对应的我们页面组件则不需要改变

```jsx
// 页面组件
import React from 'react'

@addCart
export default class Page extends Components {
  constructor(props) {
    super(props);
  }
  
  render(){
    const { onAddCart } = this.props
    return (
    	<div>
        <button onClick={onAddCart}>加购</button>
      </div>
    )
  }
}
```

### 最后

装饰器是可以传递参数的与`react-redux`的`connect`方法类似，只是太简单了没什么好写的。熟悉`vue`的可以把高阶函数当成`vue`里的`mixin`
